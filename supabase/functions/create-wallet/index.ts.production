import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

// Convert hex string to Uint8Array
function hexToBytes(hex: string): Uint8Array {
  const bytes = new Uint8Array(hex.length / 2)
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.substr(i, 2), 16)
  }
  return bytes
}

// Convert Uint8Array to base64 string
function bytesToBase64(bytes: Uint8Array): string {
  let binary = ''
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i])
  }
  return btoa(binary)
}

// Parse PEM public key to get the key data
function parsePemPublicKey(pemKey: string): Uint8Array {
  const base64Key = pemKey
    .replace(/-----BEGIN PUBLIC KEY-----/g, '')
    .replace(/-----END PUBLIC KEY-----/g, '')
    .replace(/\n/g, '')
    .replace(/\r/g, '')
    .trim()
  
  return new Uint8Array(atob(base64Key).split('').map(char => char.charCodeAt(0)))
}

// Function to generate fresh entity secret ciphertext using Web Crypto API
async function generateFreshEntitySecretCiphertext(entitySecretHex: string, publicKeyPem: string): Promise<string> {
  try {
    // Convert hex entity secret to bytes
    const entitySecretBytes = hexToBytes(entitySecretHex)
    
    // Parse the PEM public key
    const publicKeyData = parsePemPublicKey(publicKeyPem)
    
    // Import the public key for Web Crypto API
    const publicKey = await crypto.subtle.importKey(
      'spki',
      publicKeyData,
      {
        name: 'RSA-OAEP',
        hash: 'SHA-256'
      },
      false,
      ['encrypt']
    )
    
    // Encrypt using RSA-OAEP with SHA-256
    const encryptedData = await crypto.subtle.encrypt(
      {
        name: 'RSA-OAEP'
      },
      publicKey,
      entitySecretBytes
    )
    
    // Convert to base64
    return bytesToBase64(new Uint8Array(encryptedData))
    
  } catch (error) {
    console.error('Entity secret encryption failed:', error)
    throw new Error('Failed to encrypt entity secret')
  }
}

interface CreateWalletRequest {
  userId: string
  userType: 'buyer' | 'seller'
  name: string
  email: string
}

interface CircleWalletResponse {
  data: {
    wallet: {
      id: string
      state: string
      walletSetId: string
      custodyType: string
      address?: string
      blockchain: string
      accountType: string
      updateDate: string
      createDate: string
    }
  }
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // Initialize Supabase client with service role key
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    const supabase = createClient(supabaseUrl, supabaseServiceKey)

    // Get Circle API credentials
    const circleApiKey = Deno.env.get('CIRCLE_API_KEY')
    const circleApiUrl = Deno.env.get('CIRCLE_API_URL') || 'https://api.circle.com'
    const circleEntitySecretHex = Deno.env.get('CIRCLE_ENTITY_SECRET_HEX')
    const circlePublicKey = Deno.env.get('CIRCLE_PUBLIC_KEY')

    if (!circleApiKey) {
      throw new Error('Circle API key not configured')
    }

    if (!circleEntitySecretHex) {
      throw new Error('Circle entity secret hex not configured')
    }

    if (!circlePublicKey) {
      throw new Error('Circle public key not configured')
    }

    // Verify authentication
    const authHeader = req.headers.get('Authorization')
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: 'No authorization header' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    const token = authHeader.replace('Bearer ', '')
    const { data: { user }, error: authError } = await supabase.auth.getUser(token)

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Invalid authentication' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Parse request body
    const requestBody: CreateWalletRequest = await req.json()
    const { userId, userType, name, email } = requestBody

    // Validate request
    if (!userId || !userType || !name || !email) {
      return new Response(
        JSON.stringify({ error: 'Missing required fields' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Verify user owns the wallet being created
    if (user.id !== userId) {
      return new Response(
        JSON.stringify({ error: 'Unauthorized wallet creation' }),
        { status: 403, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Check if wallet already exists
    const { data: existingWallet } = await supabase
      .from('user_wallets')
      .select('*')
      .eq('user_id', userId)
      .single()

    if (existingWallet) {
      return new Response(
        JSON.stringify({ 
          success: true, 
          wallet: existingWallet,
          message: 'Wallet already exists' 
        }),
        { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Create developer-controlled wallet with Circle API
    const walletDescription = `${userType.charAt(0).toUpperCase() + userType.slice(1)} wallet for ${name}`
    const walletSetId = Deno.env.get('CIRCLE_WALLET_SET_ID')
    
    if (!walletSetId) {
      throw new Error('Circle wallet set ID not configured')
    }
    
    // Generate UUID v4 for idempotency
    const idempotencyKey = crypto.randomUUID()
    
    // Generate fresh entity secret ciphertext using Web Crypto API
    const entitySecretCiphertext = await generateFreshEntitySecretCiphertext(
      circleEntitySecretHex,
      circlePublicKey
    )
    
    console.log('Circle API Request (Developer-Controlled):', {
      url: `${circleApiUrl}/v1/w3s/developer/wallets`,
      walletSetId,
      idempotencyKey,
      blockchains: ['MATIC-AMOY'],
      ciphertextLength: entitySecretCiphertext.length
    })
    
    const circleResponse = await fetch(`${circleApiUrl}/v1/w3s/developer/wallets`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${circleApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        idempotencyKey: idempotencyKey,
        blockchains: ['MATIC-AMOY'],
        entitySecretCiphertext: entitySecretCiphertext,
        walletSetId: walletSetId
      })
    })

    if (!circleResponse.ok) {
      const errorText = await circleResponse.text()
      console.error('Circle API Error:', errorText)
      throw new Error(`Circle API error: ${circleResponse.status} - ${errorText}`)
    }

    const circleData: CircleWalletResponse = await circleResponse.json()
    const wallet = circleData.data.wallet

    // Store wallet in database
    const { data: savedWallet, error: dbError } = await supabase
      .from('user_wallets')
      .insert({
        user_id: userId,
        circle_wallet_id: wallet.id,
        wallet_address: wallet.address || null,
        wallet_state: wallet.state,
        blockchain: wallet.blockchain,
        account_type: wallet.accountType,
        custody_type: wallet.custodyType,
        wallet_set_id: wallet.walletSetId,
        description: walletDescription,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single()

    if (dbError) {
      console.error('Database error:', dbError)
      throw new Error('Failed to save wallet to database')
    }

    // Log wallet creation activity
    await supabase
      .from('user_activities')
      .insert({
        user_id: userId,
        activity_type: 'wallet_created',
        description: `Created ${userType} wallet`,
        metadata: {
          wallet_id: wallet.id,
          wallet_address: wallet.address
        },
        created_at: new Date().toISOString()
      })

    return new Response(
      JSON.stringify({
        success: true,
        wallet: savedWallet,
        circle_wallet: wallet,
        message: 'Wallet created successfully'
      }),
      { status: 201, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    console.error('Wallet creation error:', error)
    return new Response(
      JSON.stringify({ 
        error: 'Failed to create wallet',
        details: error.message 
      }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})